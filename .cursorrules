# ================================
# Cursor Rules for Flex Microservice - .NET 9 + Microservices
# ================================
version: 2

# ----------------
# GENERAL CONTEXT
# ----------------
context:
  description: |
    Flex Microservice là hệ thống quản lý chứng khoán theo kiến trúc microservices, sử dụng .NET 9, 
    được thiết kế để xử lý giao dịch chứng khoán real-time, quản lý danh mục đầu tư, streaming dữ liệu thị trường. 
    Hệ thống bao gồm các service độc lập: Securities, Investor, Identity, Ordering, Inventory, System, Basket, 
    và các building blocks chung như Infrastructure, Shared, Contracts.
  conventions: |
    - Tên service viết PascalCase với prefix "Flex." (ví dụ: Flex.Securities.Api)
    - Tên container viết thường, phân tách bằng dấu gạch (ví dụ: securities-api)
    - Tên volumes kết thúc bằng _data (ví dụ: securities_data)
    - Sử dụng biến môi trường cho thông tin nhạy cảm (connection strings, passwords)
    - Images phải chỉ định version cụ thể (.NET 9.0)
    - Sử dụng docker-compose.override.yml cho cấu hình local/dev

# ----------------
# BACKEND RULES
# ----------------
backend:
  framework: ".NET 9.0 (latest LTS)"
  architecture: |
    - Microservices: mỗi service là một container riêng biệt
    - Building Blocks: Infrastructure, Shared, Contracts, EventBus.Messages
    - Modules: Security, Redis, SeriLog, Swashbuckle, EntityFrameworkCore
    - Services: Securities, Investor, Identity, Ordering, Inventory, System, Basket, Job
    - API Gateway: Ocelot cho routing và load balancing
  naming_conventions: |
    - Tên container: trùng với tên service, viết thường (ví dụ: securities-api)
    - Biến môi trường: viết hoa, phân tách bằng dấu gạch dưới (ví dụ: DEFAULT_CONNECTION)
    - Tên project: Flex.{ServiceName}.{Layer} (ví dụ: Flex.Securities.Api)
  patterns: |
    - Sử dụng docker-compose để orchestration
    - Sử dụng volumes để persist dữ liệu
    - Sử dụng environment variables cho cấu hình động
    - Entity Framework Core với Oracle database
    - Redis cho caching
    - SeriLog cho logging
    - Swagger cho API documentation

# ----------------
# SERVICES STRUCTURE
# ----------------
services:
  securities: |
    - Flex.Securities.Api: API chính cho quản lý chứng khoán
    - Port: 5000 (Docker), 7001 (Development)
    - Database: Oracle với Entity Framework Core
    - Features: Trade processing, portfolio management, market data
  investor: |
    - Flex.Investor.Api: API quản lý nhà đầu tư
    - Port: 7003 (Development)
    - Features: Investor profiles, account management
  identity: |
    - Flex.IdentityServer.Api: Identity Server với Duende
    - Flex.AspNetIdentity.Api: ASP.NET Core Identity
    - Port: 7002 (IdentityServer), 7102 (AspNetIdentity)
    - Features: Authentication, authorization, user management
  ordering: |
    - Flex.Ordering.Api: API quản lý đơn hàng
    - Flex.Ordering.Domain: Domain layer
    - Flex.Ordering.Application: Application layer
    - Flex.Ordering.Infrastructure: Infrastructure layer
    - Port: 7004 (Development)
    - Features: Order processing, workflow management
  inventory: |
    - Flex.Inventory.Api: API quản lý kho
    - Flex.Inventory.Grpc: gRPC service
    - Port: 7005 (API), 7006 (gRPC)
    - Features: Stock management, inventory tracking
  system: |
    - Flex.System.Api: API quản lý hệ thống
    - Port: 7007 (Development)
    - Features: System configuration, health checks
  basket: |
    - Flex.Basket.Api: API giỏ hàng
    - Port: 7008 (Development)
    - Features: Shopping cart functionality
  job: |
    - Flex.EmailJob.Api: Background job service
    - Port: 7009 (Development)
    - Features: Email processing, scheduled tasks

# ----------------
# BUILDING BLOCKS
# ----------------
building_blocks: |
  - Flex.Infrastructure: Common infrastructure components
  - Flex.Shared: Shared DTOs, enums, constants
  - Flex.Contracts: Domain contracts and interfaces
  - Flex.EventBus.Messages: Event bus message definitions
  - Flex.Shared.Authorization: Authorization constants and permissions
  - Flex.Grpc.Protos: gRPC protocol buffer definitions
  - Flex.Common.Logging: Common logging components

# ----------------
# MODULES
# ----------------
modules: |
  - Flex.Security: JWT authentication, token management
  - Flex.Redis: Redis caching and session management
  - Flex.SeriLog: Structured logging with Serilog
  - Flex.Swashbuckle: Swagger/OpenAPI documentation
  - Flex.EntityFrameworkCore: Entity Framework Core extensions
  - Flex.EntityFrameworkCore.Oracle: Oracle database provider
  - Flex.Hangfire: Background job processing
  - Flex.MediaR: CQRS pattern implementation
  - Flex.DependencyInjection: DI container configuration
  - Flex.Data: Database connection management

# ----------------
# DEVOPS RULES
# ----------------
devops:
  deployment: |
    - Sử dụng docker-compose để deploy toàn bộ môi trường
    - Sử dụng docker-compose.override.yml cho cấu hình local/dev
    - Port mapping rõ ràng, tránh trùng lặp
    - Sử dụng Jenkins pipeline cho CI/CD
    - Terraform cho infrastructure provisioning
  ci_cd: |
    - Jenkins pipeline cho build, test, deploy
    - Docker images với .NET 9.0 runtime
    - Automated testing với unit tests
    - Secrets management cho thông tin nhạy cảm

# ----------------
# TESTING RULES
# ----------------
testing: |
  - Viết unit test cho từng service
  - Integration test với database containers
  - API testing với Swagger/OpenAPI
  - Performance testing cho high-load scenarios

# ----------------
# FILE & FOLDER STRUCTURE
# ----------------
file_structure: |
  - docker-compose.yml: chỉ lưu image kèm version/tag cho từng service
  - docker-compose.override.yml: cấu hình bổ sung cho môi trường local/dev
  - src/Services/: chứa các microservices
  - src/BuildingBlocks/: chứa các shared components
  - src/Modules/: chứa các reusable modules
  - src/ApiGateways/: chứa API Gateway
  - src/WebApps/: chứa web applications
  - volumes đặt tên theo convention: <service>_data
  - Mỗi service có cấu trúc: Api, Domain, Application, Infrastructure (nếu cần)

# ----------------
# DATABASE & INFRASTRUCTURE
# ----------------
infrastructure: |
  - Database: Oracle với Entity Framework Core
  - Cache: Redis cho session và caching
  - Message Broker: RabbitMQ (được đề cập trong docs)
  - API Gateway: Ocelot cho routing
  - Monitoring: Health checks và logging
  - Security: JWT tokens, Identity Server

# ----------------
# DEVELOPMENT GUIDELINES
# ----------------
development: |
  - Sử dụng .NET 9.0 SDK
  - Follow CQRS pattern với MediatR
  - Implement proper logging với Serilog
  - Use AutoMapper cho object mapping
  - Implement proper error handling và validation
  - Follow RESTful API conventions
  - Use async/await patterns
  - Implement proper dependency injection

# ----------------
# PAGING PATTERNS
# ----------------
paging_patterns: |
  ## Standard Paging Method Structure
  ```csharp
  /// <summary>
  /// Get all [EntityName] with pagination.
  /// </summary>
  public async Task<PagedResult<[EntityName]ListItemDto>> Get[EntityName]PagedAsync(Get[EntityName]PagingRequest request)
  {
      // ===== Process request parameters =====
      var keyword = request?.Keyword?.Trim().ToLower();
      var status = request?.IsActive?.Trim().ToUpper() == "Y" ? true : false;
      int pageIndex = Math.Max(1, request.PageIndex ?? 1);
      int pageSize = Math.Max(1, request.PageSize ?? 10);

      // ===== Build query =====
      var query = _context.[EntityName]s
          .WhereIf(!string.IsNullOrEmpty(keyword),
              x => EF.Functions.Like(x.Code.ToLower(), $"%{keyword}%") ||
                   EF.Functions.Like(x.Description.ToLower(), $"%{keyword}%"))
          .WhereIf(!string.IsNullOrEmpty(request.IsActive), x => x.IsActive == status);

      // ===== Execute query =====
      var total = await query.CountAsync();
      var items = await query
          .OrderBy(x => x.Id)
          .Skip((pageIndex - 1) * pageSize)
          .Take(pageSize)
          .Select(x => new [EntityName]ListItemDto
          {
              Code = x.Code,
              Name = x.Name,
              Description = x.Description,
              IsActive = x.IsActive
          })
          .ToListAsync();

      // ===== Return result =====
      return PagedResult<[EntityName]ListItemDto>.Create(pageIndex, pageSize, total, items);
  }
  ```

  ## Paging Rules & Conventions
  - **Method Naming**: Get[EntityName]PagedAsync hoặc Get[EntityName]ApprovedPagedAsync
  - **Parameter Validation**: Luôn validate và set default values cho pageIndex, pageSize
  - **Keyword Search**: Sử dụng EF.Functions.Like cho case-insensitive search
  - **Status Filter**: Convert string "Y"/"N" thành boolean
  - **Query Structure**: 
    - Process parameters → Build query → Execute query → Return result
  - **Comments**: Sử dụng comment blocks với "=====" để phân chia rõ ràng
  - **Ordering**: Mặc định OrderBy(x => x.Id) trừ khi có yêu cầu khác
  - **Projection**: Sử dụng Select để map sang DTO trước khi ToListAsync()
  - **Return Type**: Luôn sử dụng PagedResult<T>.Create()

  ## Approved vs Regular Paging
  - **Regular Paging**: Get[EntityName]PagedAsync - lấy tất cả records
  - **Approved Paging**: Get[EntityName]ApprovedPagedAsync - chỉ lấy approved records
  - **Logic Difference**: Chỉ khác ở điều kiện WHERE (IsApproved = true)
  - **Structure**: Giống hệt nhau về style, chỉ khác logic filter

  ## Common Patterns
  - **Keyword Search**: Code, Name, Description fields
  - **Status Filter**: IsActive, IsApproved, IsDeleted fields
  - **Date Range**: CreatedDate, UpdatedDate với FromDate/ToDate
  - **User Filter**: CreatedBy, UpdatedBy với user ID
  - **Category Filter**: CategoryId, TypeId với dropdown values

  ## Constants & Magic Strings
  - **ALWAYS CHECK EXISTING CONSTANTS**: Trước khi hardcode string values, tìm kiếm constants đã có
  - **Common Constants**: 
    - `StatusConstant.All` thay vì `"ALL"`
    - `StatusConstant.Approved` thay vì `"APPROVED"`
    - `RequestTypeConstant.All` thay vì `"ALL"` (cho request type filter)
    - `RequestTypeConstant.Create/Update/Delete` thay vì `"CREATE"/"UPDATE"/"DELETE"`
  - **Search Pattern**: `grep_search` với `"VALUE"` để tìm constants
  - **Location**: Constants thường ở `src/BuildingBlocks/Flex.Shared/Constants/` hoặc `src/BuildingBlocks/Flex.Shared/SeedWork/Workflow/Constants/`
  - **Naming**: Constants viết PascalCase với suffix "Constant" (ví dụ: StatusConstant, RequestTypeConstant)
  - **Request Type Filtering**: Luôn sử dụng `RequestTypeConstant.All` để lọc tất cả loại request (C/R/U/D)

# ----------------
# ENTITY MANAGEMENT WORKFLOW
# ----------------
entity_management_workflow: |
  ## Complete Entity Management Flow
  Luồng quản lý đối tượng (Entity) theo thứ tự bắt buộc:
  1. **Entities** → 2. **Configurations** → 3. **Repositories** → 4. **Services** → 5. **DI Registration** → 6. **Controllers**

  ## 1. ENTITIES CREATION
  ### Entity Base Structure
  ```csharp
  public class [EntityName] : EntityBase
  {
      public string Code { get; set; }
      public string Name { get; set; }
      public string Description { get; set; }
      public bool IsActive { get; set; } = true;
      public bool IsApproved { get; set; } = false;
      public string ApprovedBy { get; set; }
      public DateTime? ApprovedDate { get; set; }
      public string RequestType { get; set; } // CREATE, UPDATE, DELETE
      public string RequestedBy { get; set; }
      public DateTime RequestedDate { get; set; } = DateTime.UtcNow;
  }
  ```

  ### Entity Rules
  - **Inheritance**: Luôn kế thừa từ `EntityBase`
  - **Required Fields**: Code, Name, Description, IsActive, IsApproved
  - **Workflow Fields**: ApprovedBy, ApprovedDate, RequestType, RequestedBy, RequestedDate
  - **Default Values**: IsActive = true, IsApproved = false, RequestedDate = DateTime.UtcNow
  - **Naming**: PascalCase, không có prefix/suffix

  ## 2. PERSISTENCE CONFIGURATIONS
  ### Configuration Structure
  ```csharp
  public class [EntityName]Configuration : IEntityTypeConfiguration<[EntityName]>
  {
      public void Configure(EntityTypeBuilder<[EntityName]> builder)
      {
          builder.ToTable("[EntityName]s");
          
          builder.HasKey(x => x.Id);
          
          builder.Property(x => x.Code)
              .IsRequired()
              .HasMaxLength(50);
              
          builder.Property(x => x.Name)
              .IsRequired()
              .HasMaxLength(200);
              
          builder.Property(x => x.Description)
              .HasMaxLength(500);
              
          builder.Property(x => x.IsActive)
              .IsRequired()
              .HasDefaultValue(true);
              
          builder.Property(x => x.IsApproved)
              .IsRequired()
              .HasDefaultValue(false);
              
          builder.Property(x => x.RequestType)
              .IsRequired()
              .HasMaxLength(20);
              
          builder.Property(x => x.RequestedDate)
              .IsRequired()
              .HasDefaultValueSql("SYSDATE");
      }
    }
  ```

  ### Configuration Rules
  - **Table Name**: Plural form với suffix "s" (ví dụ: Roles, Securities)
  - **Primary Key**: Luôn sử dụng Id từ EntityBase
  - **Required Fields**: Code, Name, IsActive, IsApproved, RequestType, RequestedDate
  - **String Lengths**: Code(50), Name(200), Description(500), RequestType(20)
  - **Default Values**: IsActive(true), IsApproved(false), RequestedDate(SYSDATE)

  ## 3. REPOSITORIES & INTERFACES
  ### Repository Interface
  ```csharp
  public interface I[EntityName]Repository : IRepository<[EntityName]>
  {
      Task<PagedResult<[EntityName]ListItemDto>> Get[EntityName]PagedAsync(Get[EntityName]PagingRequest request);
      Task<PagedResult<[EntityName]ListItemDto>> Get[EntityName]ApprovedPagedAsync(Get[EntityName]PagingRequest request);
      Task<[EntityName]> GetByCodeAsync(string code);
      Task<bool> IsCodeExistsAsync(string code, int? excludeId = null);
      Task<bool> IsNameExistsAsync(string name, int? excludeId = null);
  }
  ```

  ### Repository Implementation
  ```csharp
  public class [EntityName]Repository : RepositoryBase<[EntityName], long, TDbContext>, I[EntityName]Repository
  {
      private readonly TDbContext _context;
      public [EntityName]Repository(TDbContext dbContext, IUnitOfWork<TDbContext> unitOfWork)
          : base(dbContext, unitOfWork)
      {
          _context = dbContext;
      }

      public async Task<PagedResult<[EntityName]ListItemDto>> Get[EntityName]PagedAsync(Get[EntityName]PagingRequest request)
      {
          // ===== Process request parameters =====
          var keyword = request?.Keyword?.Trim().ToLower();
          var status = request?.IsActive?.Trim().ToUpper() == "Y" ? true : false;
          int pageIndex = Math.Max(1, request.PageIndex ?? 1);
          int pageSize = Math.Max(1, request.PageSize ?? 10);

          // ===== Build query =====
          var query = _context.[EntityName]s
              .WhereIf(!string.IsNullOrEmpty(keyword),
                  x => EF.Functions.Like(x.Code.ToLower(), $"%{keyword}%") ||
                       EF.Functions.Like(x.Name.ToLower(), $"%{keyword}%") ||
                       EF.Functions.Like(x.Description.ToLower(), $"%{keyword}%"))
              .WhereIf(!string.IsNullOrEmpty(request.IsActive), x => x.IsActive == status);

          // ===== Execute query =====
          var total = await query.CountAsync();
          var items = await query
              .OrderBy(x => x.Id)
              .Skip((pageIndex - 1) * pageSize)
              .Take(pageSize)
              .Select(x => new [EntityName]ListItemDto
              {
                  Id = x.Id,
                  Code = x.Code,
                  Name = x.Name,
                  Description = x.Description,
                  IsActive = x.IsActive,
                  IsApproved = x.IsApproved,
                  RequestType = x.RequestType,
                  RequestedBy = x.RequestedBy,
                  RequestedDate = x.RequestedDate
              })
              .ToListAsync();

          // ===== Return result =====
          return PagedResult<[EntityName]ListItemDto>.Create(pageIndex, pageSize, total, items);
      }

      public async Task<PagedResult<[EntityName]ListItemDto>> Get[EntityName]ApprovedPagedAsync(Get[EntityName]PagingRequest request)
      {
          // ===== Process request parameters =====
          var keyword = request?.Keyword?.Trim().ToLower();
          var status = request?.IsActive?.Trim().ToUpper() == "Y" ? true : false;
          int pageIndex = Math.Max(1, request.PageIndex ?? 1);
          int pageSize = Math.Max(1, request.PageSize ?? 10);

          // ===== Build query =====
          var query = _context.[EntityName]s
              .Where(x => x.IsApproved == true) // Chỉ lấy approved records
              .WhereIf(!string.IsNullOrEmpty(keyword),
                  x => EF.Functions.Like(x.Code.ToLower(), $"%{keyword}%") ||
                       EF.Functions.Like(x.Name.ToLower(), $"%{keyword}%") ||
                       EF.Functions.Like(x.Description.ToLower(), $"%{keyword}%"))
              .WhereIf(!string.IsNullOrEmpty(request.IsActive), x => x.IsActive == status);

          // ===== Execute query =====
          var total = await query.CountAsync();
          var items = await query
              .OrderBy(x => x.Id)
              .Skip((pageIndex - 1) * pageSize)
              .Take(pageSize)
              .Select(x => new [EntityName]ListItemDto
              {
                  Id = x.Id,
                  Code = x.Code,
                  Name = x.Name,
                  Description = x.Description,
                  IsActive = x.IsActive,
                  IsApproved = x.IsApproved,
                  RequestType = x.RequestType,
                  RequestedBy = x.RequestedBy,
                  RequestedDate = x.RequestedDate
              })
              .ToListAsync();

          // ===== Return result =====
          return PagedResult<[EntityName]ListItemDto>.Create(pageIndex, pageSize, total, items);
      }

      public async Task<[EntityName]> GetByCodeAsync(string code)
      {
          return await _context.[EntityName]s
              .FirstOrDefaultAsync(x => x.Code == code);
      }

      public async Task<bool> IsCodeExistsAsync(string code, int? excludeId = null)
      {
          return await _context.[EntityName]s
              .AnyAsync(x => x.Code == code && (!excludeId.HasValue || x.Id != excludeId.Value));
      }

      public async Task<bool> IsNameExistsAsync(string name, int? excludeId = null)
      {
          return await _context.[EntityName]s
              .AnyAsync(x => x.Name == name && (!excludeId.HasValue || x.Id != excludeId.Value));
      }
  }
  ```

  ### Repository Rules
  - **Interface Naming**: I[EntityName]Repository
  - **Implementation Naming**: [EntityName]Repository
  - **Required Methods**: GetPagedAsync, GetApprovedPagedAsync, GetByCodeAsync, IsCodeExistsAsync, IsNameExistsAsync
  - **Paging Methods**: Luôn có cả regular và approved versions
  - **Validation Methods**: IsCodeExistsAsync, IsNameExistsAsync với excludeId parameter

  ## 4. SERVICES
  ### Service Interface
  ```csharp
  public interface I[EntityName]Service
  {
      Task<PagedResult<[EntityName]ListItemDto>> Get[EntityName]PagedAsync(Get[EntityName]PagingRequest request);
      Task<PagedResult<[EntityName]ListItemDto>> Get[EntityName]ApprovedPagedAsync(Get[EntityName]PagingRequest request);
      Task<[EntityName]DetailDto> GetByIdAsync(int id);
      Task<[EntityName]DetailDto> GetByCodeAsync(string code);
      Task<int> CreateAsync(Create[EntityName]Request request);
      Task<int> UpdateAsync(int id, Update[EntityName]Request request);
      Task<int> DeleteAsync(int id);
      Task<int> ApproveAsync(int id, Approve[EntityName]Request request);
      Task<int> RejectAsync(int id, Reject[EntityName]Request request);
  }
  ```

  ### Service Implementation
  ```csharp
  public class [EntityName]Service : I[EntityName]Service
  {
      private readonly I[EntityName]Repository _[entityName]Repository;
      private readonly IUnitOfWork _unitOfWork;

      public [EntityName]Service(I[EntityName]Repository [entityName]Repository, IUnitOfWork unitOfWork)
      {
          _[entityName]Repository = [entityName]Repository;
          _unitOfWork = unitOfWork;
      }

      public async Task<PagedResult<[EntityName]ListItemDto>> Get[EntityName]PagedAsync(Get[EntityName]PagingRequest request)
      {
          return await _[entityName]Repository.Get[EntityName]PagedAsync(request);
      }

      public async Task<PagedResult<[EntityName]ListItemDto>> Get[EntityName]ApprovedPagedAsync(Get[EntityName]PagingRequest request)
      {
          return await _[entityName]Repository.Get[EntityName]ApprovedPagedAsync(request);
      }

      public async Task<[EntityName]DetailDto> GetByIdAsync(int id)
      {
          var entity = await _[entityName]Repository.GetByIdAsync(id);
          if (entity == null)
              throw new NotFoundException($"[EntityName] with id {id} not found");

          return new [EntityName]DetailDto
          {
              Id = entity.Id,
              Code = entity.Code,
              Name = entity.Name,
              Description = entity.Description,
              IsActive = entity.IsActive,
              IsApproved = entity.IsApproved,
              RequestType = entity.RequestType,
              RequestedBy = entity.RequestedBy,
              RequestedDate = entity.RequestedDate,
              ApprovedBy = entity.ApprovedBy,
              ApprovedDate = entity.ApprovedDate
          };
      }

      public async Task<[EntityName]DetailDto> GetByCodeAsync(string code)
      {
          var entity = await _[entityName]Repository.GetByCodeAsync(code);
          if (entity == null)
              throw new NotFoundException($"[EntityName] with code {code} not found");

          return new [EntityName]DetailDto
          {
              Id = entity.Id,
              Code = entity.Code,
              Name = entity.Name,
              Description = entity.Description,
              IsActive = entity.IsActive,
              IsApproved = entity.IsApproved,
              RequestType = entity.RequestType,
              RequestedBy = entity.RequestedBy,
              RequestedDate = entity.RequestedDate,
              ApprovedBy = entity.ApprovedBy,
              ApprovedDate = entity.ApprovedDate
          };
      }

      public async Task<int> CreateAsync(Create[EntityName]Request request)
      {
          // ===== Validation =====
          if (await _[entityName]Repository.IsCodeExistsAsync(request.Code))
              throw new ValidationException($"Code '{request.Code}' already exists");

          if (await _[entityName]Repository.IsNameExistsAsync(request.Name))
              throw new ValidationException($"Name '{request.Name}' already exists");

          // ===== Create entity =====
          var entity = new [EntityName]
          {
              Code = request.Code.Trim(),
              Name = request.Name.Trim(),
              Description = request.Description?.Trim(),
              IsActive = request.IsActive,
              IsApproved = false,
              RequestType = RequestTypeConstant.Create,
              RequestedBy = request.RequestedBy,
              RequestedDate = DateTime.UtcNow
          };

          await _[entityName]Repository.AddAsync(entity);
          await _unitOfWork.SaveChangesAsync();

          return entity.Id;
      }

      public async Task<int> UpdateAsync(int id, Update[EntityName]Request request)
      {
          // ===== Get existing entity =====
          var entity = await _[entityName]Repository.GetByIdAsync(id);
          if (entity == null)
              throw new NotFoundException($"[EntityName] with id {id} not found");

          // ===== Validation =====
          if (await _[entityName]Repository.IsCodeExistsAsync(request.Code, id))
              throw new ValidationException($"Code '{request.Code}' already exists");

          if (await _[entityName]Repository.IsNameExistsAsync(request.Name, id))
              throw new ValidationException($"Name '{request.Name}' already exists");

          // ===== Update entity =====
          entity.Code = request.Code.Trim();
          entity.Name = request.Name.Trim();
          entity.Description = request.Description?.Trim();
          entity.IsActive = request.IsActive;
          entity.IsApproved = false;
          entity.RequestType = RequestTypeConstant.Update;
          entity.RequestedBy = request.RequestedBy;
          entity.RequestedDate = DateTime.UtcNow;

          await _[entityName]Repository.UpdateAsync(entity);
          await _unitOfWork.SaveChangesAsync();

          return entity.Id;
      }

      public async Task<int> DeleteAsync(int id)
      {
          // ===== Get existing entity =====
          var entity = await _[entityName]Repository.GetByIdAsync(id);
          if (entity == null)
              throw new NotFoundException($"[EntityName] with id {id} not found");

          // ===== Soft delete =====
          entity.IsActive = false;
          entity.IsApproved = false;
          entity.RequestType = RequestTypeConstant.Delete;
          entity.RequestedBy = "SYSTEM"; // Hoặc lấy từ current user
          entity.RequestedDate = DateTime.UtcNow;

          await _[entityName]Repository.UpdateAsync(entity);
          await _unitOfWork.SaveChangesAsync();

          return entity.Id;
      }

      public async Task<int> ApproveAsync(int id, Approve[EntityName]Request request)
      {
          // ===== Get existing entity =====
          var entity = await _[entityName]Repository.GetByIdAsync(id);
          if (entity == null)
              throw new NotFoundException($"[EntityName] with id {id} not found");

          if (entity.IsApproved)
              throw new ValidationException($"[EntityName] with id {id} is already approved");

          // ===== Approve entity =====
          entity.IsApproved = true;
          entity.ApprovedBy = request.ApprovedBy;
          entity.ApprovedDate = DateTime.UtcNow;

          await _[entityName]Repository.UpdateAsync(entity);
          await _unitOfWork.SaveChangesAsync();

          return entity.Id;
      }

      public async Task<int> RejectAsync(int id, Reject[EntityName]Request request)
      {
          // ===== Get existing entity =====
          var entity = await _[entityName]Repository.GetByIdAsync(id);
          if (entity == null)
              throw new NotFoundException($"[EntityName] with id {id} not found");

          if (entity.IsApproved)
              throw new ValidationException($"[EntityName] with id {id} is already approved");

          // ===== Reject entity =====
          entity.IsApproved = false;
          entity.IsActive = false; // Deactivate rejected entity
          entity.ApprovedBy = request.RejectedBy;
          entity.ApprovedDate = DateTime.UtcNow;

          await _[entityName]Repository.UpdateAsync(entity);
          await _unitOfWork.SaveChangesAsync();

          return entity.Id;
      }
  }
  ```

  ### Service Rules
  - **Interface Naming**: I[EntityName]Service
  - **Implementation Naming**: [EntityName]Service
  - **Required Methods**: CRUD operations + Approve/Reject workflow
  - **Validation**: Code/Name uniqueness, existence checks
  - **Workflow**: CREATE/UPDATE/DELETE → Pending → Approve/Reject
  - **Error Handling**: NotFoundException, ValidationException
  - **Constants**: Sử dụng RequestTypeConstant.Create/Update/Delete

  ## 5. DI REGISTRATION
  ### AddInfrastructureServices Extension
  ```csharp
  public static class ServiceCollectionExtensions
  {
      public static IServiceCollection AddInfrastructureServices(this IServiceCollection services)
      {
          // ===== Repository Registration =====
          services.AddScoped<I[EntityName]Repository, [EntityName]Repository>();
          
          // ===== Service Registration =====
          services.AddScoped<I[EntityName]Service, [EntityName]Service>();
          
          return services;
      }
  }
  ```

  ### DI Registration Rules
  - **Repository**: AddScoped<I[EntityName]Repository, [EntityName]Repository>
  - **Service**: AddScoped<I[EntityName]Service, [EntityName]Service>
  - **Lifetime**: Scoped cho database operations
  - **Location**: Trong AddInfrastructureServices extension method

  ## 6. CONTROLLERS
  ### Controller Structure
  ```csharp
  [ApiController]
  [Route("api/[controller]")]
  public class [EntityName]Controller : ControllerBase
  {
      private readonly I[EntityName]Service _[entityName]Service;

      public [EntityName]Controller(I[EntityName]Service [entityName]Service)
      {
          _[entityName]Service = [entityName]Service;
      }

      /// <summary>
      /// Get all [EntityName] with pagination.
      /// </summary>
      [HttpGet]
      public async Task<ActionResult<PagedResult<[EntityName]ListItemDto>>> GetPaged([FromQuery] Get[EntityName]PagingRequest request)
      {
          var result = await _[entityName]Service.Get[EntityName]PagedAsync(request);
          return Ok(result);
      }

      /// <summary>
      /// Get all approved [EntityName] with pagination.
      /// </summary>
      [HttpGet("approved")]
      public async Task<ActionResult<PagedResult<[EntityName]ListItemDto>>> GetApprovedPaged([FromQuery] Get[EntityName]PagingRequest request)
      {
          var result = await _[entityName]Service.Get[EntityName]ApprovedPagedAsync(request);
          return Ok(result);
      }

      /// <summary>
      /// Get [EntityName] by id.
      /// </summary>
      [HttpGet("{id}")]
      public async Task<ActionResult<[EntityName]DetailDto>> GetById(int id)
      {
          var result = await _[entityName]Service.GetByIdAsync(id);
          return Ok(result);
      }

      /// <summary>
      /// Get [EntityName] by code.
      /// </summary>
      [HttpGet("code/{code}")]
      public async Task<ActionResult<[EntityName]DetailDto>> GetByCode(string code)
      {
          var result = await _[entityName]Service.GetByCodeAsync(code);
          return Ok(result);
      }

      /// <summary>
      /// Create new [EntityName].
      /// </summary>
      [HttpPost]
      public async Task<ActionResult<int>> Create([FromBody] Create[EntityName]Request request)
      {
          var result = await _[entityName]Service.CreateAsync(request);
          return CreatedAtAction(nameof(GetById), new { id = result }, result);
      }

      /// <summary>
      /// Update [EntityName].
      /// </summary>
      [HttpPut("{id}")]
      public async Task<ActionResult<int>> Update(int id, [FromBody] Update[EntityName]Request request)
      {
          var result = await _[entityName]Service.UpdateAsync(id, request);
          return Ok(result);
      }

      /// <summary>
      /// Delete [EntityName].
      /// </summary>
      [HttpDelete("{id}")]
      public async Task<ActionResult<int>> Delete(int id)
      {
          var result = await _[entityName]Service.DeleteAsync(id);
          return Ok(result);
      }

      /// <summary>
      /// Approve [EntityName].
      /// </summary>
      [HttpPost("{id}/approve")]
      public async Task<ActionResult<int>> Approve(int id, [FromBody] Approve[EntityName]Request request)
      {
          var result = await _[entityName]Service.ApproveAsync(id, request);
          return Ok(result);
      }

      /// <summary>
      /// Reject [EntityName].
      /// </summary>
      [HttpPost("{id}/reject")]
      public async Task<ActionResult<int>> Reject(int id, [FromBody] Reject[EntityName]Request request)
      {
          var result = await _[entityName]Service.RejectAsync(id, request);
          return Ok(result);
      }
  }
  ```

  ### Controller Rules
  - **Naming**: [EntityName]Controller
  - **Route**: api/[controller]
  - **HTTP Methods**: GET, POST, PUT, DELETE
  - **Workflow Endpoints**: POST /{id}/approve, POST /{id}/reject
  - **Response Types**: ActionResult<T> với proper HTTP status codes
  - **Documentation**: XML comments cho Swagger
  - **Validation**: Model validation tự động với [ApiController]

  ## WORKFLOW SUMMARY
  ### Complete Flow Steps
  1. **Create Entity** → Inherit EntityBase, add workflow fields
  2. **Create Configuration** → Configure table, constraints, defaults
  3. **Create Repository Interface** → Define CRUD + paging methods
  4. **Create Repository Implementation** → Implement all methods with proper patterns
  5. **Create Service Interface** → Define business logic methods
  6. **Create Service Implementation** → Implement workflow + validation
  7. **Register DI** → Add to AddInfrastructureServices
  8. **Create Controller** → Implement REST API endpoints

  ### Required DTOs
  - **Get[EntityName]PagingRequest**: Paging parameters
  - **[EntityName]ListItemDto**: List view data
  - **[EntityName]DetailDto**: Detail view data
  - **Create[EntityName]Request**: Create operation
  - **Update[EntityName]Request**: Update operation
  - **Approve[EntityName]Request**: Approve operation
  - **Reject[EntityName]Request**: Reject operation

  ### Workflow States
  - **Pending**: IsApproved = false, có RequestType
  - **Approved**: IsApproved = true, có ApprovedBy/ApprovedDate
  - **Rejected**: IsApproved = false, IsActive = false

# ----------------
# COMPLETE ENTITY MANAGEMENT WORKFLOW (ROLE-BASED PATTERN)
# ----------------
complete_entity_workflow: |
  ## Complete Entity Management Flow
  Luồng tạo và quản lý đối tượng (Entity) theo pattern Role làm base, bao gồm đầy đủ approve/reject workflow:

  ## IMPORTANT BASE CLASS RULES
  - **Entity**: Luôn kế thừa từ `EntityBase<long>` (không phải `EntityBase`)
  - **Request Entity**: Luôn kế thừa từ `RequestBase<long>` (không phải `EntityBase`)
  - **Repository Interface**: Luôn kế thừa từ `IRepositoryBase<T, long, TDbContext>`
  - **Repository Implementation**: Luôn kế thừa từ `RepositoryBase<T, long, TDbContext>`
  - **Paging Request**: Phải implement `protected override Dictionary<string, string> OrderByMappings`

  ### PAGING REQUEST TEMPLATE
  ```csharp
  public class Get[EntityName]PagingRequest : PagingRequest
  {
      public string? Keyword { get; set; }
      public string? IsActive { get; set; }
      public string? RequestType { get; set; }

      protected override Dictionary<string, string> OrderByMappings => new()
      {
          { "code", "Code" },
          { "name", "Name" },
          { "description", "Description" },
          { "status", "Status" },
          { "createdDate", "CreatedDate" }
      };
  }
  ```

  ### 1. ENTITY CREATION
  ```csharp
  // src/Services/Identity/Flex.AspNetIdentity.Api/Entities/[EntityName].cs
  public class [EntityName] : EntityBase<long>
  {
      public string Code { get; set; } = default!;
      public string Name { get; set; } = default!;
      public string Description { get; set; } = default!;
      public string Status { get; set; } = StatusConstant.Approved;
      public bool IsActive { get; set; } = true;
      
      // Navigation properties nếu cần
      public virtual ICollection<[RelatedEntity]> [RelatedEntities] { get; set; } = new List<[RelatedEntity]>();
  }
  ```

  ### 2. REQUEST ENTITY (cho workflow)
  ```csharp
  // src/Services/Identity/Flex.AspNetIdentity.Api/Entities/[EntityName]Request.cs
  public class [EntityName]Request : RequestBase<long>
  {
      public string Action { get; set; } = default!; // CREATE, UPDATE, DELETE
      public long EntityId { get; set; } // ID của entity gốc (0 cho CREATE)
      public string EntityCode { get; set; } = default!; // Code của entity
      public string Status { get; set; } = RequestStatusConstant.Unauthorised;
      public string? CheckerId { get; set; }
      public DateTime? ApproveDate { get; set; }
      public string? Comments { get; set; }
      
      // Data fields (JSON serialized)
      public string RequestData { get; set; } = default!;
      public string? OriginalData { get; set; } // Cho UPDATE/DELETE
  }
  ```

  ### 3. PERSISTENCE CONFIGURATIONS
  ```csharp
  // src/Services/Identity/Flex.AspNetIdentity.Api/Data/Configurations/[EntityName]Configuration.cs
  public class [EntityName]Configuration : IEntityTypeConfiguration<[EntityName]>
  {
      public void Configure(EntityTypeBuilder<[EntityName]> builder)
      {
          builder.ToTable("[EntityName]s");
          builder.HasKey(x => x.Id);
          
          builder.Property(x => x.Code)
              .IsRequired()
              .HasMaxLength(50);
              
          builder.Property(x => x.Name)
              .IsRequired()
              .HasMaxLength(200);
              
          builder.Property(x => x.Description)
              .HasMaxLength(500);
              
          builder.Property(x => x.Status)
              .IsRequired()
              .HasMaxLength(20);
              
          builder.HasIndex(x => x.Code).IsUnique();
      }
  }
  ```

  ```csharp
  // src/Services/Identity/Flex.AspNetIdentity.Api/Data/Configurations/[EntityName]RequestConfiguration.cs
  public class [EntityName]RequestConfiguration : IEntityTypeConfiguration<[EntityName]Request>
  {
      public void Configure(EntityTypeBuilder<[EntityName]Request> builder)
      {
          builder.ToTable("[EntityName]Requests");
          builder.HasKey(x => x.Id);
          
          builder.Property(x => x.Action)
              .IsRequired()
              .HasMaxLength(20);
              
          builder.Property(x => x.EntityCode)
              .IsRequired()
              .HasMaxLength(50);
              
          builder.Property(x => x.Status)
              .IsRequired()
              .HasMaxLength(20);
              
          builder.Property(x => x.RequestData)
              .IsRequired();
              
          builder.Property(x => x.OriginalData);
      }
  }
  ```

  ### 4. REPOSITORIES & INTERFACES
  ```csharp
  // src/Services/Identity/Flex.AspNetIdentity.Api/Repositories/Interfaces/I[EntityName]Repository.cs
  public interface I[EntityName]Repository : IRepositoryBase<[EntityName], long, TDbContext>
  {
      Task<[EntityName]?> GetByCodeAsync(string code);
      Task<bool> ExistsByCodeAsync(string code);
      Task<PagedResult<[EntityName]ListItemDto>> GetPagedAsync(Get[EntityName]PagingRequest request);
      Task<PagedResult<[EntityName]ListItemDto>> GetApprovedPagedAsync(Get[EntityName]PagingRequest request);
  }
  ```

  ```csharp
  // src/Services/Identity/Flex.AspNetIdentity.Api/Repositories/Interfaces/I[EntityName]RequestRepository.cs
  public interface I[EntityName]RequestRepository : IRepositoryBase<[EntityName]Request, long, TDbContext>
  {
      Task<PagedResult<[EntityName]PendingPagingDto>> GetPendingPagedAsync(Get[EntityName]PagingRequest request);
      Task<[EntityName]Request?> GetPendingByIdAsync(long requestId);
  }
  ```

  ```csharp
  // src/Services/Identity/Flex.AspNetIdentity.Api/Repositories/[EntityName]Repository.cs
  public class [EntityName]Repository : Repository<[EntityName]>, I[EntityName]Repository
  {
      public [EntityName]Repository(ApplicationDbContext context) : base(context)
      {
      }

      public async Task<[EntityName]?> GetByCodeAsync(string code)
      {
          return await _context.[EntityName]s
              .FirstOrDefaultAsync(x => x.Code == code);
      }

      public async Task<bool> ExistsByCodeAsync(string code)
      {
          return await _context.[EntityName]s
              .AnyAsync(x => x.Code == code);
      }

      public async Task<PagedResult<[EntityName]ListItemDto>> GetPagedAsync(Get[EntityName]PagingRequest request)
      {
          // ===== Process request parameters =====
          var keyword = request?.Keyword?.Trim().ToLower();
          var status = request?.IsActive?.Trim().ToUpper() == "Y" ? true : false;
          int pageIndex = Math.Max(1, request.PageIndex ?? 1);
          int pageSize = Math.Max(1, request.PageSize ?? 10);

          // ===== Build query =====
          var query = _context.[EntityName]s
              .WhereIf(!string.IsNullOrEmpty(keyword),
                  x => EF.Functions.Like(x.Code.ToLower(), $"%{keyword}%") ||
                       EF.Functions.Like(x.Name.ToLower(), $"%{keyword}%") ||
                       EF.Functions.Like(x.Description.ToLower(), $"%{keyword}%"))
              .WhereIf(!string.IsNullOrEmpty(request.IsActive), x => x.IsActive == status);

          // ===== Execute query =====
          var total = await query.CountAsync();
          var items = await query
              .OrderBy(x => x.Id)
              .Skip((pageIndex - 1) * pageSize)
              .Take(pageSize)
              .Select(x => new [EntityName]ListItemDto
              {
                  Id = x.Id,
                  Code = x.Code,
                  Name = x.Name,
                  Description = x.Description,
                  Status = x.Status,
                  IsActive = x.IsActive
              })
              .ToListAsync();

          // ===== Return result =====
          return PagedResult<[EntityName]ListItemDto>.Create(pageIndex, pageSize, total, items);
      }

      public async Task<PagedResult<[EntityName]ListItemDto>> GetApprovedPagedAsync(Get[EntityName]PagingRequest request)
      {
          // ===== Process request parameters =====
          var keyword = request?.Keyword?.Trim().ToLower();
          var status = request?.IsActive?.Trim().ToUpper() == "Y" ? true : false;
          int pageIndex = Math.Max(1, request.PageIndex ?? 1);
          int pageSize = Math.Max(1, request.PageSize ?? 10);

          // ===== Build query =====
          var query = _context.[EntityName]s
              .Where(x => x.Status == StatusConstant.Approved)
              .WhereIf(!string.IsNullOrEmpty(keyword),
                  x => EF.Functions.Like(x.Code.ToLower(), $"%{keyword}%") ||
                       EF.Functions.Like(x.Name.ToLower(), $"%{keyword}%") ||
                       EF.Functions.Like(x.Description.ToLower(), $"%{keyword}%"))
              .WhereIf(!string.IsNullOrEmpty(request.IsActive), x => x.IsActive == status);

          // ===== Execute query =====
          var total = await query.CountAsync();
          var items = await query
              .OrderBy(x => x.Id)
              .Skip((pageIndex - 1) * pageSize)
              .Take(pageSize)
              .Select(x => new [EntityName]ListItemDto
              {
                  Id = x.Id,
                  Code = x.Code,
                  Name = x.Name,
                  Description = x.Description,
                  Status = x.Status,
                  IsActive = x.IsActive
              })
              .ToListAsync();

          // ===== Return result =====
          return PagedResult<[EntityName]ListItemDto>.Create(pageIndex, pageSize, total, items);
      }
  }
  ```

  ```csharp
  // src/Services/Identity/Flex.AspNetIdentity.Api/Repositories/[EntityName]RequestRepository.cs
  public class [EntityName]RequestRepository : RepositoryBase<[EntityName]Request, long, TDbContext>, I[EntityName]RequestRepository
  {
      private readonly TDbContext _context;
      public [EntityName]RequestRepository(TDbContext dbContext, IUnitOfWork<TDbContext> unitOfWork)
          : base(dbContext, unitOfWork)
      {
          _context = dbContext;
      }

      public async Task<PagedResult<[EntityName]PendingPagingDto>> GetPendingPagedAsync(Get[EntityName]PagingRequest request)
      {
          // ===== Process request parameters =====
          var keyword = request?.Keyword?.Trim().ToLower();
          var requestType = request?.RequestType?.Trim().ToUpper();
          int pageIndex = Math.Max(1, request.PageIndex ?? 1);
          int pageSize = Math.Max(1, request.PageSize ?? 10);

          // ===== Build query =====
          var query = _context.[EntityName]Requests
              .Where(x => x.Status == RequestStatusConstant.Unauthorised)
              .WhereIf(!string.IsNullOrEmpty(keyword),
                  x => EF.Functions.Like(x.EntityCode.ToLower(), $"%{keyword}%"))
              .WhereIf(!string.IsNullOrEmpty(requestType) && requestType != RequestTypeConstant.All,
                  x => x.Action == requestType);

          // ===== Execute query =====
          var total = await query.CountAsync();
          var items = await query
              .OrderByDescending(x => x.CreatedDate)
              .Skip((pageIndex - 1) * pageSize)
              .Take(pageSize)
              .Select(x => new [EntityName]PendingPagingDto
              {
                  Id = x.Id,
                  EntityCode = x.EntityCode,
                  Action = x.Action,
                  Status = x.Status,
                  CreatedBy = x.CreatedBy,
                  CreatedDate = x.CreatedDate
              })
              .ToListAsync();

          // ===== Return result =====
          return PagedResult<[EntityName]PendingPagingDto>.Create(pageIndex, pageSize, total, items);
      }

      public async Task<[EntityName]Request?> GetPendingByIdAsync(long requestId)
      {
          return await _context.[EntityName]Requests
              .FirstOrDefaultAsync(x => x.Id == requestId && x.Status == RequestStatusConstant.Unauthorised);
      }
  }
  ```

  ### 5. DTOs
  ```csharp
  // src/Services/Identity/Flex.AspNetIdentity.Api/Models/[EntityName]Dto.cs
  public class [EntityName]Dto
  {
      public long Id { get; set; }
      public string Code { get; set; } = default!;
      public string Name { get; set; } = default!;
      public string Description { get; set; } = default!;
      public string Status { get; set; } = default!;
      public bool IsActive { get; set; }
      public DateTime CreatedDate { get; set; }
      public string CreatedBy { get; set; } = default!;
  }

  public class [EntityName]ListItemDto
  {
      public long Id { get; set; }
      public string Code { get; set; } = default!;
      public string Name { get; set; } = default!;
      public string Description { get; set; } = default!;
      public string Status { get; set; } = default!;
      public bool IsActive { get; set; }
  }

  public class Create[EntityName]RequestDto
  {
      public string Code { get; set; } = default!;
      public string Name { get; set; } = default!;
      public string Description { get; set; } = default!;
  }

  public class Update[EntityName]RequestDto
  {
      public string Name { get; set; } = default!;
      public string Description { get; set; } = default!;
  }

  public class Delete[EntityName]RequestDto
  {
      public string Reason { get; set; } = default!;
  }

  public class [EntityName]PendingPagingDto
  {
      public long Id { get; set; }
      public string EntityCode { get; set; } = default!;
      public string Action { get; set; } = default!;
      public string Status { get; set; } = default!;
      public string CreatedBy { get; set; } = default!;
      public DateTime CreatedDate { get; set; }
  }

  public class [EntityName]RequestDetailDto
  {
      public long Id { get; set; }
      public string Action { get; set; } = default!;
      public long EntityId { get; set; }
      public string EntityCode { get; set; } = default!;
      public string Status { get; set; } = default!;
      public string CreatedBy { get; set; } = default!;
      public DateTime CreatedDate { get; set; }
      public string? CheckerId { get; set; }
      public DateTime? ApproveDate { get; set; }
      public string? Comments { get; set; }
      public [EntityName]Dto? RequestData { get; set; }
      public [EntityName]Dto? OriginalData { get; set; }
  }

  public class Approve[EntityName]RequestDto
  {
      public string? Comment { get; set; }
  }

  public class Reject[EntityName]RequestDto
  {
      public string? Reason { get; set; }
  }

  public class [EntityName]ApprovalResultDto
  {
      public long RequestId { get; set; }
      public string RequestType { get; set; } = default!;
      public string Status { get; set; } = default!;
      public string ApprovedBy { get; set; } = default!;
      public DateTime ApprovedDate { get; set; }
      public string Comment { get; set; } = default!;
  }
  ```

  ### 6. SERVICE INTERFACE
  ```csharp
  // src/Services/Identity/Flex.AspNetIdentity.Api/Services/Interfaces/I[EntityName]Service.cs
  public interface I[EntityName]Service
  {
      // Query
      Task<PagedResult<[EntityName]ListItemDto>> GetApproved[EntityName]sPagedAsync(Get[EntityName]PagingRequest request);
      Task<[EntityName]Dto> GetApproved[EntityName]ByCodeAsync(string code);
      Task<List<[EntityName]ChangeHistoryDto>> GetApproved[EntityName]ChangeHistoryAsync(string code);
      
      // Command
      Task<long> Create[EntityName]RequestAsync(Create[EntityName]RequestDto request);
      Task<long> CreateUpdate[EntityName]RequestAsync(string code, Update[EntityName]RequestDto dto);
      Task<long> CreateDelete[EntityName]RequestAsync(string code, Delete[EntityName]RequestDto request);
      
      // Pending Management
      Task<PagedResult<[EntityName]PendingPagingDto>> GetPending[EntityName]sPagedAsync(Get[EntityName]PagingRequest request);
      Task<[EntityName]RequestDetailDto> GetPending[EntityName]ByIdAsync(long requestId);
      Task<[EntityName]ApprovalResultDto> ApprovePending[EntityName]RequestAsync(long requestId, string? comment = null);
      Task<[EntityName]ApprovalResultDto> RejectPending[EntityName]RequestAsync(long requestId, string? reason = null);
  }
  ```

  ### 7. SERVICE IMPLEMENTATION
  ```csharp
  // src/Services/Identity/Flex.AspNetIdentity.Api/Services/[EntityName]Service.cs
  public class [EntityName]Service : I[EntityName]Service
  {
      private readonly I[EntityName]Repository _[entityName]Repository;
      private readonly I[EntityName]RequestRepository _[entityName]RequestRepository;
      private readonly IUserService _userService;

      public [EntityName]Service(
          I[EntityName]Repository [entityName]Repository,
          I[EntityName]RequestRepository [entityName]RequestRepository,
          IUserService userService)
      {
          _[entityName]Repository = [entityName]Repository;
          _[entityName]RequestRepository = [entityName]RequestRepository;
          _userService = userService;
      }

      #region Query
      public async Task<PagedResult<[EntityName]ListItemDto>> GetApproved[EntityName]sPagedAsync(Get[EntityName]PagingRequest request)
      {
          return await _[entityName]Repository.GetApprovedPagedAsync(request);
      }

      public async Task<[EntityName]Dto> GetApproved[EntityName]ByCodeAsync(string code)
      {
          var entity = await _[entityName]Repository.GetByCodeAsync(code);
          if (entity == null || entity.Status != StatusConstant.Approved)
          {
              throw new Exception($"[EntityName] with code '{code}' not found or not approved.");
          }

          return new [EntityName]Dto
          {
              Id = entity.Id,
              Code = entity.Code,
              Name = entity.Name,
              Description = entity.Description,
              Status = entity.Status,
              IsActive = entity.IsActive,
              CreatedDate = entity.CreatedDate,
              CreatedBy = entity.CreatedBy
          };
      }

      public async Task<List<[EntityName]ChangeHistoryDto>> GetApproved[EntityName]ChangeHistoryAsync(string code)
      {
          // Implementation for change history
          throw new NotImplementedException();
      }
      #endregion

      #region Command
      public async Task<long> Create[EntityName]RequestAsync(Create[EntityName]RequestDto request)
      {
          // ===== Validation =====
          if (await _[entityName]Repository.ExistsByCodeAsync(request.Code))
          {
              throw new Exception($"[EntityName] with code '{request.Code}' already exists.");
          }

          var requester = _userService.GetCurrentUsername() ?? "system";
          if (string.IsNullOrWhiteSpace(requester))
          {
              throw new ArgumentException("Requester cannot be empty.");
          }

          // ===== Create request =====
          var [entityName]Request = new [EntityName]Request
          {
              Action = RequestTypeConstant.Create,
              EntityId = 0,
              EntityCode = request.Code,
              Status = RequestStatusConstant.Unauthorised,
              RequestData = JsonSerializer.Serialize(new
              {
                  Code = request.Code,
                  Name = request.Name,
                  Description = request.Description
              }),
              CreatedBy = requester
          };

          await _[entityName]RequestRepository.AddAsync([entityName]Request);
          return [entityName]Request.Id;
      }

      public async Task<long> CreateUpdate[EntityName]RequestAsync(string code, Update[EntityName]RequestDto dto)
      {
          // ===== Validation =====
          var existingEntity = await _[entityName]Repository.GetByCodeAsync(code);
          if (existingEntity == null || existingEntity.Status != StatusConstant.Approved)
          {
              throw new Exception($"[EntityName] with code '{code}' not found or not approved.");
          }

          var requester = _userService.GetCurrentUsername() ?? "system";
          if (string.IsNullOrWhiteSpace(requester))
          {
              throw new ArgumentException("Requester cannot be empty.");
          }

          // ===== Create update request =====
          var [entityName]Request = new [EntityName]Request
          {
              Action = RequestTypeConstant.Update,
              EntityId = existingEntity.Id,
              EntityCode = code,
              Status = RequestStatusConstant.Unauthorised,
              RequestData = JsonSerializer.Serialize(dto),
              OriginalData = JsonSerializer.Serialize(new
              {
                  Name = existingEntity.Name,
                  Description = existingEntity.Description
              }),
              CreatedBy = requester
          };

          // ===== Update entity status =====
          existingEntity.Status = StatusConstant.Pending;
          await _[entityName]Repository.UpdateAsync(existingEntity);

          await _[entityName]RequestRepository.AddAsync([entityName]Request);
          return [entityName]Request.Id;
      }

      public async Task<long> CreateDelete[EntityName]RequestAsync(string code, Delete[EntityName]RequestDto request)
      {
          // ===== Validation =====
          var existingEntity = await _[entityName]Repository.GetByCodeAsync(code);
          if (existingEntity == null || existingEntity.Status != StatusConstant.Approved)
          {
              throw new Exception($"[EntityName] with code '{code}' not found or not approved.");
          }

          var requester = _userService.GetCurrentUsername() ?? "system";
          if (string.IsNullOrWhiteSpace(requester))
          {
              throw new ArgumentException("Requester cannot be empty.");
          }

          // ===== Create delete request =====
          var [entityName]Request = new [EntityName]Request
          {
              Action = RequestTypeConstant.Delete,
              EntityId = existingEntity.Id,
              EntityCode = code,
              Status = RequestStatusConstant.Unauthorised,
              RequestData = JsonSerializer.Serialize(request),
              OriginalData = JsonSerializer.Serialize(new
              {
                  Name = existingEntity.Name,
                  Description = existingEntity.Description
              }),
              CreatedBy = requester
          };

          // ===== Update entity status =====
          existingEntity.Status = StatusConstant.Pending;
          await _[entityName]Repository.UpdateAsync(existingEntity);

          await _[entityName]RequestRepository.AddAsync([entityName]Request);
          return [entityName]Request.Id;
      }
      #endregion

      #region Pending Management
      public async Task<PagedResult<[EntityName]PendingPagingDto>> GetPending[EntityName]sPagedAsync(Get[EntityName]PagingRequest request)
      {
          return await _[entityName]RequestRepository.GetPendingPagedAsync(request);
      }

      public async Task<[EntityName]RequestDetailDto> GetPending[EntityName]ByIdAsync(long requestId)
      {
          var request = await _[entityName]RequestRepository.GetPendingByIdAsync(requestId);
          if (request == null)
          {
              throw new Exception($"Pending [EntityName] request with ID '{requestId}' not found.");
          }

          return new [EntityName]RequestDetailDto
          {
              Id = request.Id,
              Action = request.Action,
              EntityId = request.EntityId,
              EntityCode = request.EntityCode,
              Status = request.Status,
              CreatedBy = request.CreatedBy,
              CreatedDate = request.CreatedDate,
              CheckerId = request.CheckerId,
              ApproveDate = request.ApproveDate,
              Comments = request.Comments,
              RequestData = !string.IsNullOrEmpty(request.RequestData) 
                  ? JsonSerializer.Deserialize<[EntityName]Dto>(request.RequestData) 
                  : null,
              OriginalData = !string.IsNullOrEmpty(request.OriginalData) 
                  ? JsonSerializer.Deserialize<[EntityName]Dto>(request.OriginalData) 
                  : null
          };
      }

      public async Task<[EntityName]ApprovalResultDto> ApprovePending[EntityName]RequestAsync(long requestId, string? comment = null)
      {
          // ===== Validation =====
          if (requestId <= 0)
          {
              throw new ArgumentException("RequestId must be greater than 0.", nameof(requestId));
          }

          var approver = _userService.GetCurrentUsername() ?? "system";
          if (string.IsNullOrWhiteSpace(approver))
          {
              throw new ArgumentException("Approver cannot be empty.");
          }

          // ===== Get request data =====
          var request = await _[entityName]RequestRepository
              .FindAll()
              .AsNoTracking()
              .FirstOrDefaultAsync(r => r.Id == requestId && r.Status == RequestStatusConstant.Unauthorised);

          if (request == null)
          {
              throw new Exception($"Pending [EntityName] request with ID '{requestId}' not found.");
          }

          // ===== Process approval with transaction =====
          await using var transaction = await _[entityName]RequestRepository.BeginTransactionAsync();
          try
          {
              // ===== Process entity changes =====
              await Process[EntityName]Approval(request);

              // ===== Update request status =====
              await UpdateRequestStatus(request, approver, comment);

              await transaction.CommitAsync();

              // ===== Return result =====
              return new [EntityName]ApprovalResultDto
              {
                  RequestId = request.Id,
                  RequestType = request.Action,
                  Status = RequestStatusConstant.Authorised,
                  ApprovedBy = approver,
                  ApprovedDate = DateTime.UtcNow,
                  Comment = comment ?? "Approved"
              };
          }
          catch
          {
              await transaction.RollbackAsync();
              throw new Exception($"Failed to approve [EntityName] request ID '{requestId}'.");
          }
      }

      public async Task<[EntityName]ApprovalResultDto> RejectPending[EntityName]RequestAsync(long requestId, string? reason = null)
      {
          // ===== Validation =====
          if (requestId <= 0)
          {
              throw new ArgumentException("RequestId must be greater than 0.", nameof(requestId));
          }

          var rejecter = _userService.GetCurrentUsername() ?? "system";
          if (string.IsNullOrWhiteSpace(rejecter))
          {
              throw new ArgumentException("Rejecter cannot be empty.");
          }

          // ===== Get request data =====
          var request = await _[entityName]RequestRepository
              .FindAll()
              .AsNoTracking()
              .FirstOrDefaultAsync(r => r.Id == requestId && r.Status == RequestStatusConstant.Unauthorised);

          if (request == null)
          {
              throw new Exception($"Pending [EntityName] request with ID '{requestId}' not found.");
          }

          // ===== Process rejection with transaction =====
          await using var transaction = await _[entityName]RequestRepository.BeginTransactionAsync();
          try
          {
              // ===== Revert entity status if needed =====
              await Revert[EntityName]StatusIfNeeded(request);

              // ===== Update request status =====
              await UpdateRejectedRequestStatus(request, rejecter, reason);

              await transaction.CommitAsync();

              // ===== Return result =====
              return new [EntityName]ApprovalResultDto
              {
                  RequestId = request.Id,
                  RequestType = request.Action,
                  Status = RequestStatusConstant.Rejected,
                  ApprovedBy = rejecter,
                  ApprovedDate = DateTime.UtcNow,
                  Comment = reason ?? "Rejected"
              };
          }
          catch
          {
              await transaction.RollbackAsync();
              throw new Exception($"Failed to reject [EntityName] request ID '{requestId}'.");
          }
      }
      #endregion

      #region Private Methods
      private async Task Process[EntityName]Approval([EntityName]Request request)
      {
          switch (request.Action)
          {
              case RequestTypeConstant.Create:
                  await ProcessCreate[EntityName](request);
                  break;
              case RequestTypeConstant.Update:
                  await ProcessUpdate[EntityName](request);
                  break;
              case RequestTypeConstant.Delete:
                  await ProcessDelete[EntityName](request);
                  break;
              default:
                  throw new ArgumentException($"Unsupported action: {request.Action}");
          }
      }

      private async Task ProcessCreate[EntityName]([EntityName]Request request)
      {
          var requestData = JsonSerializer.Deserialize<Create[EntityName]RequestDto>(request.RequestData);
          if (requestData == null)
          {
              throw new Exception("Invalid request data for CREATE action.");
          }

          var [entityName] = new [EntityName]
          {
              Code = requestData.Code,
              Name = requestData.Name,
              Description = requestData.Description,
              Status = StatusConstant.Approved,
              IsActive = true,
              CreatedBy = request.CreatedBy
          };

          await _[entityName]Repository.AddAsync([entityName]);
      }

      private async Task ProcessUpdate[EntityName]([EntityName]Request request)
      {
          var requestData = JsonSerializer.Deserialize<Update[EntityName]RequestDto>(request.RequestData);
          if (requestData == null)
          {
              throw new Exception("Invalid request data for UPDATE action.");
          }

          var [entityName] = await _[entityName]Repository.FindByIdAsync(request.EntityId);
          if ([entityName] == null)
          {
              throw new Exception($"[EntityName] with ID '{request.EntityId}' not found.");
          }

          [entityName].Name = requestData.Name;
          [entityName].Description = requestData.Description;
          [entityName].Status = StatusConstant.Approved;

          await _[entityName]Repository.UpdateAsync([entityName]);
      }

      private async Task ProcessDelete[EntityName]([EntityName]Request request)
      {
          var [entityName] = await _[entityName]Repository.FindByIdAsync(request.EntityId);
          if ([entityName] == null)
          {
              throw new Exception($"[EntityName] with ID '{request.EntityId}' not found.");
          }

          [entityName].IsActive = false;
          [entityName].Status = StatusConstant.Deleted;

          await _[entityName]Repository.UpdateAsync([entityName]);
      }

      private async Task Revert[EntityName]StatusIfNeeded([EntityName]Request request)
      {
          if ((request.Action == RequestTypeConstant.Update || request.Action == RequestTypeConstant.Delete) 
              && request.EntityId > 0)
          {
              var [entityName] = await _[entityName]Repository.FindByIdAsync(request.EntityId);
              if ([entityName] != null)
              {
                  [entityName].Status = StatusConstant.Approved; // Revert to approved status
                  await _[entityName]Repository.UpdateAsync([entityName]);
              }
          }
      }

      private async Task UpdateRequestStatus([EntityName]Request request, string approver, string? comment)
      {
          request.Status = RequestStatusConstant.Authorised;
          request.CheckerId = approver;
          request.ApproveDate = DateTime.UtcNow;
          request.Comments = comment ?? "Approved";

          await _[entityName]RequestRepository.UpdateAsync(request);
      }

      private async Task UpdateRejectedRequestStatus([EntityName]Request request, string rejecter, string? reason)
      {
          request.Status = RequestStatusConstant.Rejected;
          request.CheckerId = rejecter;
          request.ApproveDate = DateTime.UtcNow;
          request.Comments = reason ?? "Rejected";

          await _[entityName]RequestRepository.UpdateAsync(request);
      }
      #endregion
  }
  ```

  ### 8. CONTROLLER
  ```csharp
  // src/Services/Identity/Flex.AspNetIdentity.Api/Controllers/[EntityName]Controller.cs
  [ApiController]
  [Route("api/[controller]")]
  public class [EntityName]Controller : ControllerBase
  {
      private readonly I[EntityName]Service _[entityName]Service;

      public [EntityName]Controller(I[EntityName]Service [entityName]Service)
      {
          _[entityName]Service = [entityName]Service;
      }

      /// <summary>
      /// Get all approved [EntityName]s with pagination.
      /// </summary>
      [HttpGet]
      public async Task<IActionResult> GetApproved[EntityName]s([FromQuery] Get[EntityName]PagingRequest request)
      {
          var result = await _[entityName]Service.GetApproved[EntityName]sPagedAsync(request);
          return Ok(Result.Success(result));
      }

      /// <summary>
      /// Get approved [EntityName] by code.
      /// </summary>
      [HttpGet("{code}")]
      public async Task<IActionResult> GetApproved[EntityName]ByCode(string code)
      {
          var result = await _[entityName]Service.GetApproved[EntityName]ByCodeAsync(code);
          return Ok(Result.Success(result));
      }

      /// <summary>
      /// Create [EntityName] request.
      /// </summary>
      [HttpPost]
      public async Task<IActionResult> Create[EntityName]Request([FromBody] Create[EntityName]RequestDto request)
      {
          var requestId = await _[entityName]Service.Create[EntityName]RequestAsync(request);
          return Ok(Result.Success(new { RequestId = requestId }));
      }

      /// <summary>
      /// Create update [EntityName] request.
      /// </summary>
      [HttpPut("{code}")]
      public async Task<IActionResult> CreateUpdate[EntityName]Request(string code, [FromBody] Update[EntityName]RequestDto request)
      {
          var requestId = await _[entityName]Service.CreateUpdate[EntityName]RequestAsync(code, request);
          return Ok(Result.Success(new { RequestId = requestId }));
      }

      /// <summary>
      /// Create delete [EntityName] request.
      /// </summary>
      [HttpDelete("{code}")]
      public async Task<IActionResult> CreateDelete[EntityName]Request(string code, [FromBody] Delete[EntityName]RequestDto request)
      {
          var requestId = await _[entityName]Service.CreateDelete[EntityName]RequestAsync(code, request);
          return Ok(Result.Success(new { RequestId = requestId }));
      }

      /// <summary>
      /// Get pending [EntityName]s with pagination.
      /// </summary>
      [HttpGet("pending")]
      public async Task<IActionResult> GetPending[EntityName]s([FromQuery] Get[EntityName]PagingRequest request)
      {
          var result = await _[entityName]Service.GetPending[EntityName]sPagedAsync(request);
          return Ok(Result.Success(result));
      }

      /// <summary>
      /// Get pending [EntityName] request by ID.
      /// </summary>
      [HttpGet("pending/{requestId}")]
      public async Task<IActionResult> GetPending[EntityName]ById(long requestId)
      {
          var result = await _[entityName]Service.GetPending[EntityName]ByIdAsync(requestId);
          return Ok(Result.Success(result));
      }

      /// <summary>
      /// Approve pending [EntityName] request by ID.
      /// </summary>
      [HttpPost("pending/{requestId}/approve")]
      public async Task<IActionResult> ApprovePending[EntityName]Request(long requestId, [FromBody] Approve[EntityName]RequestDto? dto = null)
      {
          try
          {
              // ===== Validation =====
              if (requestId <= 0)
              {
                  return BadRequest(Result.Failure("RequestId must be greater than 0."));
              }

              // ===== Process approval =====
              var result = await _[entityName]Service.ApprovePending[EntityName]RequestAsync(requestId, dto?.Comment);
              
              // ===== Return result =====
              return Ok(Result.Success(result));
          }
          catch (ArgumentException ex)
          {
              return BadRequest(Result.Failure(ex.Message));
          }
          catch (Exception ex)
          {
              return StatusCode(500, Result.Failure($"Failed to approve [EntityName] request: {ex.Message}"));
          }
      }

      /// <summary>
      /// Reject pending [EntityName] request by ID.
      /// </summary>
      [HttpPost("pending/{requestId}/reject")]
      public async Task<IActionResult> RejectPending[EntityName]Request(long requestId, [FromBody] Reject[EntityName]RequestDto? dto = null)
      {
          try
          {
              // ===== Validation =====
              if (requestId <= 0)
              {
                  return BadRequest(Result.Failure("RequestId must be greater than 0."));
              }

              // ===== Process rejection =====
              var result = await _[entityName]Service.RejectPending[EntityName]RequestAsync(requestId, dto?.Reason);
              
              // ===== Return result =====
              return Ok(Result.Success(result));
          }
          catch (ArgumentException ex)
          {
              return BadRequest(Result.Failure(ex.Message));
          }
          catch (Exception ex)
          {
              return StatusCode(500, Result.Failure($"Failed to reject [EntityName] request: {ex.Message}"));
          }
      }
  }
  ```

  ### 9. DI REGISTRATION
  ```csharp
  // src/Services/Identity/Flex.AspNetIdentity.Api/Extensions/ServiceExtensions.cs
  public static class ServiceExtensions
  {
      public static IServiceCollection AddInfrastructureServices(this IServiceCollection services)
      {
          // Existing registrations...
          
          // [EntityName] Services
          services.AddScoped<I[EntityName]Repository, [EntityName]Repository>();
          services.AddScoped<I[EntityName]RequestRepository, [EntityName]RequestRepository>();
          services.AddScoped<I[EntityName]Service, [EntityName]Service>();
          
          return services;
      }
  }
  ```

  ### 10. DB CONTEXT CONFIGURATION
  ```csharp
  // src/Services/Identity/Flex.AspNetIdentity.Api/Data/ApplicationDbContext.cs
  public class ApplicationDbContext : DbContext
  {
      // Existing DbSets...
      
      public DbSet<[EntityName]> [EntityName]s { get; set; }
      public DbSet<[EntityName]Request> [EntityName]Requests { get; set; }
      
      protected override void OnModelCreating(ModelBuilder modelBuilder)
      {
          base.OnModelCreating(modelBuilder);
          
          // Existing configurations...
          
          modelBuilder.ApplyConfiguration(new [EntityName]Configuration());
          modelBuilder.ApplyConfiguration(new [EntityName]RequestConfiguration());
      }
  }
  ```

  ## Workflow Rules & Conventions
  - **Entity Naming**: [EntityName] thay thế bằng tên thực thể (ví dụ: Role, User, Permission)
  - **File Structure**: Tuân thủ cấu trúc thư mục đã định nghĩa
  - **Naming Convention**: PascalCase cho classes, camelCase cho variables
  - **Transaction Safety**: Luôn sử dụng database transaction cho approve/reject operations
  - **Error Handling**: Comprehensive error handling với proper exception messages
  - **Validation**: Input validation và business rule validation
  - **Audit Trail**: Ghi đầy đủ thông tin approve/reject (user, time, comment)
  - **Status Management**: Proper status transitions (Approved → Pending → Approved/Rejected)
  - **JSON Serialization**: Sử dụng System.Text.Json cho request data serialization
  - **Constants Usage**: Luôn sử dụng constants thay vì hardcode strings
  - **Comment Blocks**: Sử dụng "=====" để phân chia rõ ràng các sections
  - **Async/Await**: Luôn sử dụng async/await patterns
  - **Repository Pattern**: Strict separation giữa data access và business logic
  - **Service Layer**: Business logic tập trung trong service layer
  - **Controller Responsibility**: Chỉ handle HTTP requests và responses
  - **DI Registration**: Đăng ký đầy đủ dependencies trong ServiceExtensions
